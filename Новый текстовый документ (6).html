<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Roman.io Reborn</title>
<style>
:root {
  --bg-a: #0a1626;
  --bg-b: #112b3c;
  --bg-c: #1e4f68;
  --panel: rgba(7, 17, 30, 0.75);
  --line: rgba(255, 255, 255, 0.12);
  --text: #e9f6ff;
  --muted: #a7c0d4;
  --accent: #4dd7a8;
  --accent-strong: #31bc8e;
  --danger: #ff6b6b;
  --gold: #ffd166;
  --shadow: 0 18px 40px rgba(0, 0, 0, 0.35);
}

* {
  box-sizing: border-box;
}

html,
body {
  width: 100%;
  height: 100%;
  margin: 0;
  overflow: hidden;
  font-family: "Segoe UI", "Trebuchet MS", sans-serif;
  color: var(--text);
  background: radial-gradient(circle at 20% 15%, #2a7b9b 0%, var(--bg-b) 45%, var(--bg-a) 100%);
}

canvas {
  position: fixed;
  inset: 0;
  width: 100%;
  height: 100%;
  display: block;
}

#hud {
  position: fixed;
  top: 14px;
  left: 14px;
  right: 14px;
  display: flex;
  justify-content: space-between;
  gap: 12px;
  pointer-events: none;
  z-index: 4;
}

#joystick {
  position: fixed;
  left: 16px;
  bottom: 16px;
  width: 132px;
  height: 132px;
  border-radius: 50%;
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(6px);
  z-index: 7;
  display: none;
  touch-action: none;
}

#mobileActions {
  position: fixed;
  right: 14px;
  bottom: 24px;
  z-index: 7;
  display: none;
  flex-direction: column;
  align-items: flex-end;
  gap: 10px;
}

#mobileEject {
  width: 84px;
  height: 84px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.24);
  background: rgba(255, 159, 67, 0.9);
  color: #1a1207;
  font-size: 15px;
  font-weight: 800;
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  touch-action: none;
}

.mobileSkill {
  width: 72px;
  height: 72px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.24);
  color: #071221;
  font-size: 13px;
  font-weight: 800;
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  touch-action: none;
  display: none;
}

#mobileStun {
  background: rgba(144, 181, 255, 0.9);
}

#mobileSpeed {
  background: rgba(126, 240, 204, 0.95);
}

#mobileDash {
  background: rgba(255, 222, 115, 0.95);
}

#joystickStick {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 58px;
  height: 58px;
  margin-left: -29px;
  margin-top: -29px;
  border-radius: 50%;
  background: rgba(126, 240, 204, 0.9);
  border: 2px solid rgba(255, 255, 255, 0.7);
  box-shadow: 0 8px 22px rgba(0, 0, 0, 0.35);
  transform: translate(0px, 0px);
}

.hud-card {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 14px;
  padding: 10px 14px;
  min-width: 185px;
  backdrop-filter: blur(10px);
  box-shadow: var(--shadow);
}

.hud-label {
  font-size: 12px;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--muted);
}

.hud-value {
  margin-top: 4px;
  font-size: 22px;
  font-weight: 700;
}

#statusLine {
  margin-top: 4px;
  font-size: 12px;
  color: var(--gold);
}

#pauseExitButton {
  position: fixed;
  top: 18px;
  left: 50%;
  transform: translateX(-50%);
  z-index: 9;
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px 12px;
  font-size: 13px;
  font-weight: 700;
  color: var(--text);
  background: rgba(8, 19, 33, 0.78);
  display: none;
}

#defenseHealButton {
  position: fixed;
  left: 160px;
  bottom: 38px;
  z-index: 9;
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px 12px;
  font-size: 13px;
  font-weight: 700;
  color: #082018;
  background: linear-gradient(135deg, #9ef8dd, #4dd7a8);
  display: none;
}

#defenseHealButton.cooldown {
  color: var(--text);
  background: rgba(8, 19, 33, 0.78);
  cursor: default;
}

#defenseHintBanner {
  position: fixed;
  left: 14px;
  bottom: 14px;
  z-index: 9;
  max-width: 340px;
  border: 1px solid var(--line);
  border-radius: 10px;
  padding: 8px 10px;
  font-size: 12px;
  color: var(--text);
  background: rgba(8, 19, 33, 0.82);
  display: none;
}

#menu,
#gameOver {
  position: fixed;
  inset: 0;
  z-index: 5;
  display: grid;
  place-items: center;
  background: linear-gradient(160deg, rgba(0, 0, 0, 0.46), rgba(0, 0, 0, 0.7));
  overflow-y: auto;
  padding: 12px;
}

#gameOver {
  z-index: 6;
  display: none;
}

#experimentalMenu {
  position: fixed;
  inset: 0;
  z-index: 8;
  display: none;
  place-items: center;
  background: linear-gradient(160deg, rgba(0, 0, 0, 0.52), rgba(0, 0, 0, 0.74));
  overflow-y: auto;
  padding: 12px;
}

#pauseMenu {
  position: fixed;
  inset: 0;
  z-index: 10;
  display: none;
  place-items: center;
  background: linear-gradient(160deg, rgba(0, 0, 0, 0.52), rgba(0, 0, 0, 0.74));
  overflow-y: auto;
  padding: 12px;
}

.panel {
  width: min(92vw, 760px);
  border-radius: 20px;
  border: 1px solid var(--line);
  background: linear-gradient(150deg, rgba(13, 32, 48, 0.95), rgba(7, 17, 30, 0.9));
  box-shadow: var(--shadow);
  padding: 26px;
}

h1,
h2,
p {
  margin: 0;
}

h1 {
  font-size: clamp(32px, 6vw, 52px);
  letter-spacing: 0.03em;
}

.subtitle {
  margin-top: 6px;
  color: var(--muted);
}

.menu-grid {
  margin-top: 18px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
  gap: 10px;
}

.mode-card {
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 12px;
  background: rgba(255, 255, 255, 0.03);
  cursor: pointer;
  transition: border-color 0.2s, transform 0.2s, background 0.2s;
}

.mode-card.active {
  border-color: var(--accent);
  background: rgba(77, 215, 168, 0.12);
  transform: translateY(-2px);
}

.mode-card.disabled {
  opacity: 0.55;
  border-style: dashed;
}

.mode-title {
  font-size: 15px;
  font-weight: 700;
}

.mode-desc {
  margin-top: 6px;
  font-size: 12px;
  color: var(--muted);
}

.row {
  margin-top: 14px;
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  gap: 12px;
}

input[type="file"] {
  max-width: 100%;
  color: var(--muted);
}

input[type="text"] {
  max-width: 100%;
  border-radius: 10px;
  border: 1px solid var(--line);
  padding: 10px 12px;
  background: rgba(255, 255, 255, 0.06);
  color: var(--text);
}

.btn {
  border: 0;
  border-radius: 12px;
  padding: 12px 18px;
  font-size: 15px;
  font-weight: 700;
  cursor: pointer;
  color: #082018;
  background: linear-gradient(135deg, #7ef0cc, #4dd7a8);
}

.btn:hover {
  background: linear-gradient(135deg, #a2f6da, #63e0b6);
}

.btn.alt {
  color: var(--text);
  background: rgba(255, 255, 255, 0.08);
  border: 1px solid var(--line);
}

.kb {
  margin-top: 16px;
  color: var(--muted);
  font-size: 13px;
  line-height: 1.45;
}

#boosterPanel {
  margin-top: 12px;
  display: none;
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 12px;
  background: rgba(255, 255, 255, 0.03);
}

.boosterCard {
  margin-top: 10px;
  border: 1px solid rgba(255, 255, 255, 0.12);
  border-radius: 10px;
  padding: 10px;
  background: rgba(0, 0, 0, 0.15);
}

.boosterTitle {
  font-size: 14px;
  font-weight: 700;
}

.boosterDesc {
  margin-top: 4px;
  color: var(--muted);
  font-size: 12px;
}

@media (max-width: 640px) {
  #menu,
  #gameOver,
  #experimentalMenu {
    place-items: start center;
    padding: 12px;
    overflow-y: auto;
  }

  .panel {
    width: 100%;
    max-width: 100%;
    max-height: calc(100dvh - 24px);
    overflow-y: auto;
    padding: 18px;
    border-radius: 16px;
  }

  .hud-card {
    min-width: 150px;
  }

  .hud-value {
    font-size: 18px;
  }

  #joystick {
    width: 120px;
    height: 120px;
    left: 12px;
    bottom: 12px;
  }

  #joystickStick {
    width: 52px;
    height: 52px;
    margin-left: -26px;
    margin-top: -26px;
  }

  #mobileActions {
    right: 12px;
    bottom: 18px;
  }

  #mobileEject {
    width: 76px;
    height: 76px;
    font-size: 14px;
  }

  #defenseHealButton {
    left: 136px;
    bottom: 26px;
  }

  .mobileSkill {
    width: 66px;
    height: 66px;
    font-size: 12px;
  }

  .menu-grid {
    grid-template-columns: 1fr;
  }

  .row {
    flex-direction: column;
    align-items: stretch;
  }

  .row .btn,
  .row input,
  .row label,
  .row > div {
    width: 100%;
  }
}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="joystick"><div id="joystickStick"></div></div>
<div id="mobileActions">
  <button id="mobileStun" class="mobileSkill" type="button">STUN</button>
  <button id="mobileSpeed" class="mobileSkill" type="button">SPEED</button>
  <button id="mobileDash" class="mobileSkill" type="button">DASH</button>
  <button id="mobileEject" type="button">Q / Eject</button>
</div>
<button id="pauseExitButton" type="button">Пауза / В меню</button>
<button id="defenseHealButton" type="button">Хил</button>
<div id="defenseHintBanner">Нажмите на колёсико для хила ядра. Находитесь внутри ядра чтобы его хилить</div>

<div id="hud" aria-live="polite">
  <div class="hud-card">
    <div class="hud-label">Очки</div>
    <div class="hud-value" id="scoreValue">0</div>
    <div id="statusLine">Статус: ожидание старта</div>
  </div>
  <div class="hud-card" style="text-align:right;">
    <div class="hud-label">Режим / Рекорд</div>
    <div class="hud-value" id="modeValue">Классика</div>
    <div id="bestValue" class="hud-label" style="margin-top:6px; color: var(--gold);">Best: 0</div>
  </div>
</div>

<div id="menu">
  <div class="panel">
    <h1>Roman.io Reborn</h1>
    <p class="subtitle">Новый интерфейс, новые режимы, новые шансы на выживание.</p>

    <div class="menu-grid" id="modeGrid">
      <div class="mode-card active" data-mode="classic">
        <div class="mode-title">Классика</div>
        <div class="mode-desc">Один умный бот, спокойный старт, классический рост массы.</div>
      </div>
      <div class="mode-card" data-mode="survival">
        <div class="mode-title">Выживание</div>
        <div class="mode-desc">Новые боты приходят волнами. Чем дольше живёшь, тем выше счёт.</div>
      </div>
      <div class="mode-card" data-mode="time_attack">
        <div class="mode-title">Тайм-атака (60с)</div>
        <div class="mode-desc">За минуту набери максимум очков. Темп игры заметно выше.</div>
      </div>
      <div class="mode-card" data-mode="beer_party">
        <div class="mode-title">Пивная вечеринка</div>
        <div class="mode-desc">Еда на карте заменяется на `nepivo.png`. Весёлый визуальный режим.</div>
      </div>
      <div class="mode-card" data-mode="beer_defense">
        <div class="mode-title">Защита пива</div>
        <div class="mode-desc">Защищай пивное ядро в центре карты от волн злых ботов.</div>
      </div>
      <div class="mode-card" data-mode="coop_online">
        <div class="mode-title">Кооп онлайн</div>
        <div class="mode-desc">Онлайн-режим через локальный/сетевой WebSocket сервер.</div>
      </div>
    </div>

    <div class="row">
      <label for="playerImage">Скин игрока:</label>
      <input type="file" id="playerImage" accept="image/*">
    </div>

    <div class="row" id="coopControls" style="display:none; align-items:end;">
      <div style="display:flex; flex-direction:column; gap:6px;">
        <label for="coopUrl">WS URL</label>
        <input id="coopUrl" type="text" value="wss://romanio-production.up.railway.app" list="coopUrlPresets" style="min-width:180px;">
        <datalist id="coopUrlPresets">
          <option value="wss://romanio-production.up.railway.app"></option>
          <option value="ws://192.168.2.3:8765"></option>
          <option value="ws://localhost:8765"></option>
        </datalist>
        <div style="display:flex; gap:6px; flex-wrap:wrap;">
          <button class="btn alt" id="presetRailway" type="button">Railway</button>
          <button class="btn alt" id="presetLan" type="button">LAN</button>
          <button class="btn alt" id="presetLocal" type="button">Localhost</button>
        </div>
      </div>
      <div style="display:flex; flex-direction:column; gap:6px;">
        <label for="coopRoom">Комната</label>
        <input id="coopRoom" type="text" value="party">
      </div>
      <div style="display:flex; flex-direction:column; gap:6px;">
        <label for="coopName">Ник</label>
        <input id="coopName" type="text" value="Player">
      </div>
      <button class="btn alt" id="coopConnect">Подключиться</button>
      <button class="btn alt" id="coopDisconnect">Отключиться</button>
    </div>
    <div class="row" id="coopStatusRow" style="display:none; margin-top:8px;">
      <span id="coopStatus" class="hud-label">Сеть: не подключено</span>
    </div>

    <div class="row">
      <button class="btn" id="playButton">Старт</button>
      <button class="btn alt" id="openBoosterShop">Бустеры</button>
      <button class="btn alt" id="clearBest">Сбросить рекорд</button>
    </div>

    <div id="boosterPanel">
      <div class="hud-label">Магазин бустеров (покупка за очки бустеров)</div>
      <div id="boosterClassicScore" class="boosterDesc">Доступно: 0</div>

      <div class="boosterCard">
        <div class="boosterTitle">1) Оглушение бота - 1500</div>
        <div class="boosterDesc">Оглушает ближайшего бота на 10 секунд. 3 использования. Активация только кнопкой STUN в игре.</div>
        <button class="btn alt" id="buyStun">Купить</button>
        <div id="stunOwned" class="boosterDesc">Куплено: 0</div>
      </div>

      <div class="boosterCard">
        <div class="boosterTitle">2) Супер скорость - 1500</div>
        <div class="boosterDesc">Ускоряет игрока на 5 секунд на 200% (x3). 2 использования. Активация только кнопкой SPEED в игре.</div>
        <button class="btn alt" id="buySpeed">Купить</button>
        <div id="speedOwned" class="boosterDesc">Куплено: 0</div>
      </div>

      <div class="boosterCard">
        <div class="boosterTitle">3) Повышенная масса - 2000</div>
        <div class="boosterDesc">1 раз запускает следующий раунд со стартовой массой 150%.</div>
        <button class="btn alt" id="buyMass">Купить</button>
        <div id="massOwned" class="boosterDesc">Куплено: 0</div>
      </div>
    </div>

    <div class="kb">
      Управление: мышь или WASD/стрелки. | Shift: рывок | P: меню паузы (кроме коопа)
    </div>
  </div>
</div>

<div id="gameOver">
  <div class="panel">
    <h2 id="gameOverTitle">Игра окончена</h2>
    <p id="gameOverText" class="subtitle" style="margin-top:8px;"></p>
    <div class="row" style="margin-top:18px;">
      <button class="btn" id="retryButton">Сыграть снова</button>
      <button class="btn alt" id="backMenuButton">В меню</button>
    </div>
  </div>
</div>

<div id="experimentalMenu">
  <div class="panel">
    <h2>Экспериментальное меню</h2>
    <p class="subtitle" style="margin-top:8px;">Открывается двойным нажатием по кнопке "Сбросить рекорд".</p>
    <div class="row" style="margin-top:16px;">
      <label for="expMagnet" style="display:flex; gap:8px; align-items:center;">
        <input type="checkbox" id="expMagnet">
        Новая функция: Магнит еды (притягивает еду рядом с игроком)
      </label>
    </div>
    <div class="row" style="margin-top:18px;">
      <button class="btn" id="expApply">Применить</button>
      <button class="btn alt" id="expClose">Закрыть</button>
    </div>
  </div>
</div>

<div id="pauseMenu">
  <div class="panel">
    <h2>Пауза</h2>
    <p class="subtitle" style="margin-top:8px;">Игра остановлена.</p>
    <div class="row" style="margin-top:18px;">
      <button class="btn" id="pauseContinue">Продолжить игру</button>
      <button class="btn alt" id="pauseExit">Выйти</button>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById("gameCanvas");
  const ctx = canvas.getContext("2d");

  const menu = document.getElementById("menu");
  const gameOverPanel = document.getElementById("gameOver");
  const experimentalMenu = document.getElementById("experimentalMenu");
  const pauseMenu = document.getElementById("pauseMenu");
  const playButton = document.getElementById("playButton");
  const retryButton = document.getElementById("retryButton");
  const backMenuButton = document.getElementById("backMenuButton");
  const clearBestButton = document.getElementById("clearBest");
  const openBoosterShopButton = document.getElementById("openBoosterShop");
  const boosterPanel = document.getElementById("boosterPanel");
  const boosterClassicScore = document.getElementById("boosterClassicScore");
  const buyStunButton = document.getElementById("buyStun");
  const buySpeedButton = document.getElementById("buySpeed");
  const buyMassButton = document.getElementById("buyMass");
  const stunOwned = document.getElementById("stunOwned");
  const speedOwned = document.getElementById("speedOwned");
  const massOwned = document.getElementById("massOwned");
  const expMagnet = document.getElementById("expMagnet");
  const expApplyButton = document.getElementById("expApply");
  const expCloseButton = document.getElementById("expClose");
  const pauseContinueButton = document.getElementById("pauseContinue");
  const pauseExitMenuButton = document.getElementById("pauseExit");
  const playerImageInput = document.getElementById("playerImage");
  const coopControls = document.getElementById("coopControls");
  const coopStatusRow = document.getElementById("coopStatusRow");
  const coopStatus = document.getElementById("coopStatus");
  const coopUrlInput = document.getElementById("coopUrl");
  const coopRoomInput = document.getElementById("coopRoom");
  const coopNameInput = document.getElementById("coopName");
  const coopConnectButton = document.getElementById("coopConnect");
  const coopDisconnectButton = document.getElementById("coopDisconnect");
  const presetRailwayButton = document.getElementById("presetRailway");
  const presetLanButton = document.getElementById("presetLan");
  const presetLocalButton = document.getElementById("presetLocal");

  const modeCards = Array.from(document.querySelectorAll(".mode-card"));
  const joystick = document.getElementById("joystick");
  const joystickStick = document.getElementById("joystickStick");
  const mobileActions = document.getElementById("mobileActions");
  const mobileEject = document.getElementById("mobileEject");
  const mobileStun = document.getElementById("mobileStun");
  const mobileSpeed = document.getElementById("mobileSpeed");
  const mobileDash = document.getElementById("mobileDash");
  const scoreValue = document.getElementById("scoreValue");
  const modeValue = document.getElementById("modeValue");
  const bestValue = document.getElementById("bestValue");
  const statusLine = document.getElementById("statusLine");
  const pauseExitButton = document.getElementById("pauseExitButton");
  const defenseHealButton = document.getElementById("defenseHealButton");
  const defenseHintBanner = document.getElementById("defenseHintBanner");
  const gameOverTitle = document.getElementById("gameOverTitle");
  const gameOverText = document.getElementById("gameOverText");
  const COOP_WS_URL = "wss://romanio-production.up.railway.app";

  const MODES = {
    classic: {
      label: "Классика",
      startBots: 1,
      pelletTarget: 95,
      botBaseSpeed: 112,
      scoreFromTime: false,
      duration: null,
      waveEvery: null
    },
    survival: {
      label: "Выживание",
      startBots: 2,
      pelletTarget: 115,
      botBaseSpeed: 116,
      scoreFromTime: true,
      duration: null,
      waveEvery: 8
    },
    time_attack: {
      label: "Тайм-атака",
      startBots: 2,
      pelletTarget: 150,
      botBaseSpeed: 108,
      scoreFromTime: false,
      duration: 60,
      waveEvery: null
    },
    beer_party: {
      label: "Пивная вечеринка",
      startBots: 2,
      pelletTarget: 125,
      botBaseSpeed: 114,
      scoreFromTime: false,
      duration: null,
      waveEvery: null
    },
    beer_defense: {
      label: "Защита пива",
      startBots: 0,
      pelletTarget: 120,
      botBaseSpeed: 118,
      scoreFromTime: false,
      duration: null,
      waveEvery: null
    },
    coop_online: {
      label: "Кооп онлайн",
      startBots: 0,
      pelletTarget: 140,
      botBaseSpeed: 112,
      scoreFromTime: false,
      duration: null,
      waveEvery: null
    }
  };

  const WORLD = {
    width: 4200,
    height: 4200,
    gridStep: 50
  };

  const NORMAL_PELLET_COLORS = ["#4dd7a8", "#5ec8ff", "#ffb35c", "#ff7aa2", "#c1ff6b", "#b39bff"];

  const state = {
    selectedMode: "classic",
    running: false,
    paused: false,
    pauseMenuOpen: false,
    coopLocalPaused: false,
    gameOver: false,
    player: null,
    bots: [],
    pellets: [],
    powerups: [],
    score: 0,
    elapsed: 0,
    waveTimer: 0,
    boostTimer: 0,
    superSpeedTimer: 0,
    shieldTimer: 0,
    spawnTimer: 0,
    powerupTimer: 0,
    keys: new Set(),
    mouse: { x: 0, y: 0, active: false },
    camera: { x: 0, y: 0, zoom: 1 },
    isMobile: false,
    joystick: { active: false, x: 0, y: 0, maxDist: 42, touchId: null },
    desktopPositionLock: { enabled: false, x: 0, y: 0 },
    experimental: { pelletMagnet: false },
    coopPlayers: {},
    coopInput: { x: 0, y: 0 },
    coopEjectQueue: [],
    coopSnapshotTimer: 0,
    coopInputSendTimer: 0,
    defense: {
      core: null,
      botSpawnTimer: 0,
      wave: 1,
      phase: "wave",
      phaseTimer: 0,
      healCooldown: 0,
      hintTimer: 0
    },
    network: {
      ws: null,
      connected: false,
      id: null,
      hostId: null,
      room: "party",
      name: "Player",
      url: COOP_WS_URL
    },
    clearBestClickTimer: null,
    aiId: 1,
    bestScores: loadBestScores(),
    boosterPoints: loadBoosterPoints(),
    boosters: loadBoosters(),
    lastTime: 0
  };

  const playerImage = new Image();
  playerImage.src = "dadasereza.png";
  const pelletImage = new Image();
  pelletImage.src = "nepivo.png";
  let hasCustomImage = false;

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function createPlayer() {
    return {
      x: WORLD.width / 2,
      y: WORLD.height / 2,
      radius: 32,
      baseSpeed: 210,
      vx: 0,
      vy: 0
    };
  }

  function randomPoint() {
    return {
      x: Math.random() * WORLD.width,
      y: Math.random() * WORLD.height
    };
  }

  function randomPointNear(entity, maxDistance = 520) {
    if (!entity) return randomPoint();
    const angle = Math.random() * Math.PI * 2;
    const dist = Math.random() * maxDistance;
    return {
      x: clamp(entity.x + Math.cos(angle) * dist, 0, WORLD.width),
      y: clamp(entity.y + Math.sin(angle) * dist, 0, WORLD.height)
    };
  }

  function randomPointNearAnyCoopPlayer(maxDistance = 700) {
    const players = [state.player, ...Object.values(state.coopPlayers)].filter(Boolean);
    if (!players.length) return randomPoint();
    const target = players[Math.floor(Math.random() * players.length)];
    return randomPointNear(target, maxDistance);
  }

  function syncCamera() {
    if (!state.player) return;
    const zoomOutProgress = clamp((state.score - 5000) / 30000, 0, 1);
    state.camera.zoom = 1 - zoomOutProgress * 0.45;
    const visibleWorldWidth = canvas.width / state.camera.zoom;
    const visibleWorldHeight = canvas.height / state.camera.zoom;
    const maxCamX = Math.max(0, WORLD.width - visibleWorldWidth);
    const maxCamY = Math.max(0, WORLD.height - visibleWorldHeight);
    state.camera.x = clamp(state.player.x - visibleWorldWidth / 2, 0, maxCamX);
    state.camera.y = clamp(state.player.y - visibleWorldHeight / 2, 0, maxCamY);
  }

  function screenToWorld(screenX, screenY) {
    const zoom = state.camera.zoom || 1;
    return {
      x: state.camera.x + screenX / zoom,
      y: state.camera.y + screenY / zoom
    };
  }

  function toScreenX(worldX) {
    return (worldX - state.camera.x) * (state.camera.zoom || 1);
  }

  function toScreenY(worldY) {
    return (worldY - state.camera.y) * (state.camera.zoom || 1);
  }

  function toScreenRadius(worldRadius) {
    return worldRadius * (state.camera.zoom || 1);
  }

  function pointInsideAnyPlayer(x, y, padding = 10) {
    const players = [state.player, ...Object.values(state.coopPlayers)].filter(Boolean);
    for (const p of players) {
      if (Math.hypot(x - p.x, y - p.y) < p.radius + padding) {
        return true;
      }
    }
    return false;
  }

  function spawnBot(boost = 0) {
    const p = randomPoint();
    const radius = 18 + Math.random() * 16 + boost;
    state.bots.push({
      id: state.aiId++,
      x: p.x,
      y: p.y,
      radius,
      vx: 0,
      vy: 0,
      stunTimer: 0,
      color: `hsl(${Math.floor(10 + Math.random() * 30)}, 85%, ${45 + Math.random() * 10}%)`
    });
  }

  function spawnBotAroundDefenseCore(boost = 0) {
    const core = state.defense.core;
    if (!core) return;
    const waveParams = getDefenseWaveParams(state.defense.wave || 1);
    const angle = Math.random() * Math.PI * 2;
    const dist = 360 + Math.random() * 260;
    const p = {
      x: clamp(core.x + Math.cos(angle) * dist, 0, WORLD.width),
      y: clamp(core.y + Math.sin(angle) * dist, 0, WORLD.height)
    };
    const radius = (18 + Math.random() * 14 + boost) * waveParams.spawnSizeMult;
    state.bots.push({
      id: state.aiId++,
      x: p.x,
      y: p.y,
      radius,
      vx: 0,
      vy: 0,
      stunTimer: 0,
      color: `hsl(${Math.floor(0 + Math.random() * 25)}, 85%, ${42 + Math.random() * 10}%)`
    });
  }

  function getDefenseWaveParams(wave) {
    const w = Math.max(1, Number(wave) || 1);
    const idx = w - 1;
    return {
      speedMult: Math.min(1.95, 0.78 + idx * 0.09),
      spawnSizeMult: Math.min(2.1, 0.8 + idx * 0.12),
      targetPlayerScale: Math.min(1.25, 0.82 + idx * 0.06),
      minRadius: Math.min(90, 24 + idx * 3),
      spawnInterval: Math.max(0.58, 2.1 - idx * 0.16),
      maxBots: Math.min(28, 5 + idx * 2),
      spawnBoost: 1 + idx * 1.6
    };
  }

  function spawnPellet(x = null, y = null, bonus = false) {
    let point = x === null ? randomPoint() : { x, y };
    const avoidPadding = bonus ? 14 : 10;
    for (let i = 0; i < 16 && pointInsideAnyPlayer(point.x, point.y, avoidPadding); i++) {
      point = randomPoint();
    }
    const normalColor = NORMAL_PELLET_COLORS[Math.floor(Math.random() * NORMAL_PELLET_COLORS.length)];
    state.pellets.push({
      x: point.x,
      y: point.y,
      radius: bonus ? 6.5 : 5,
      value: bonus ? 22 : 10,
      massGain: bonus ? 1.05 : 0.75,
      kind: bonus ? "bonus" : "normal",
      color: bonus ? "#ffd166" : normalColor
    });
  }

  function spawnPowerup() {
    const point = randomPoint();
    const type = Math.random() < 0.5 ? "shield" : "boost";
    state.powerups.push({
      type,
      x: point.x,
      y: point.y,
      radius: 12,
      life: 10
    });
  }

  function loadBestScores() {
    const raw = localStorage.getItem("romanio_best_v2");
    if (!raw) {
      return { classic: 0, survival: 0, time_attack: 0, beer_party: 0, beer_defense: 0, coop_online: 0 };
    }
    try {
      const parsed = JSON.parse(raw);
      return {
        classic: Number(parsed.classic) || 0,
        survival: Number(parsed.survival) || 0,
        time_attack: Number(parsed.time_attack) || 0,
        beer_party: Number(parsed.beer_party) || 0,
        beer_defense: Number(parsed.beer_defense) || 0,
        coop_online: Number(parsed.coop_online) || 0
      };
    } catch {
      return { classic: 0, survival: 0, time_attack: 0, beer_party: 0, beer_defense: 0, coop_online: 0 };
    }
  }

  function saveBestScores() {
    localStorage.setItem("romanio_best_v2", JSON.stringify(state.bestScores));
  }

  function loadBoosterPoints() {
    const raw = localStorage.getItem("romanio_booster_points_v1");
    return Math.max(0, Number(raw) || 0);
  }

  function saveBoosterPoints() {
    localStorage.setItem("romanio_booster_points_v1", String(Math.floor(state.boosterPoints)));
  }

  function loadBoosters() {
    const fallback = { stun: 0, speed: 0, mass: 0 };
    const raw = localStorage.getItem("romanio_boosters_v1");
    if (!raw) return fallback;
    try {
      const parsed = JSON.parse(raw);
      return {
        stun: Math.max(0, Number(parsed.stun) || 0),
        speed: Math.max(0, Number(parsed.speed) || 0),
        mass: Math.max(0, Number(parsed.mass) || 0)
      };
    } catch {
      return fallback;
    }
  }

  function saveBoosters() {
    localStorage.setItem("romanio_boosters_v1", JSON.stringify(state.boosters));
  }

  function updateBoosterPanel() {
    boosterClassicScore.textContent = `Доступно очков: ${Math.floor(state.boosterPoints)}`;
    stunOwned.textContent = `Куплено: ${state.boosters.stun}`;
    speedOwned.textContent = `Куплено: ${state.boosters.speed}`;
    massOwned.textContent = `Куплено: ${state.boosters.mass}`;
    buyStunButton.disabled = state.boosterPoints < 1500;
    buySpeedButton.disabled = state.boosterPoints < 1500;
    buyMassButton.disabled = state.boosterPoints < 2000;
    updateMobileSkillButtons();
  }

  function spendBoosterPoints(cost) {
    if (state.boosterPoints < cost) return false;
    state.boosterPoints -= cost;
    saveBoosterPoints();
    return true;
  }

  function buyBooster(kind, cost, amount) {
    if (!spendBoosterPoints(cost)) {
      alert("Недостаточно очков бустеров.");
      return;
    }
    state.boosters[kind] += amount;
    saveBoosters();
    updateBoosterPanel();
    updateHud();
  }

  function updateHud() {
    scoreValue.textContent = String(Math.floor(state.score));
    modeValue.textContent = MODES[state.selectedMode].label;
    bestValue.textContent = `Best: ${Math.floor(state.bestScores[state.selectedMode])}`;

    const parts = [];
    if (state.shieldTimer > 0) {
      parts.push(`Щит ${state.shieldTimer.toFixed(1)}с`);
    }
    if (state.boostTimer > 0) {
      parts.push(`Ускорение ${state.boostTimer.toFixed(1)}с`);
    }
    if (state.superSpeedTimer > 0) {
      parts.push(`Супер-скорость ${state.superSpeedTimer.toFixed(1)}с`);
    }
    if (!parts.length) {
      parts.push(state.paused ? "Пауза" : "В игре");
    }
    if (isCoopMode() && state.pauseMenuOpen) {
      parts.push("локальная пауза");
    }
    if (isCoopMode()) {
      if (!state.network.connected) parts.push("офлайн");
      else parts.push(isCoopHost() ? "хост" : "клиент");
    }
    if (state.desktopPositionLock.enabled) {
      parts.push("позиция зафиксирована");
    }
    if (state.selectedMode === "beer_defense" && state.defense.core) {
      parts.push(`Ядро HP ${Math.ceil(state.defense.core.hp)}/${state.defense.core.maxHp}`);
      if (state.defense.phase === "wave") {
        if (state.defense.phaseTimer >= 60) {
          parts.push(`Волна ${state.defense.wave}: Убейте всех ботов`);
        } else {
          const left = Math.max(0, 60 - state.defense.phaseTimer);
          parts.push(`Волна ${state.defense.wave} (${left.toFixed(0)}с)`);
        }
      } else {
        const left = Math.max(0, 15 - state.defense.phaseTimer);
        parts.push(`Перерыв ${left.toFixed(0)}с`);
      }
    }
    statusLine.textContent = `Статус: ${parts.join(" | ")}`;
    updateBoosterPanel();
    updateJoystickVisibility();
    updateDefenseHintBanner();
  }

  function updateJoystickVisibility() {
    const show = state.running && !state.paused && !state.gameOver && !state.pauseMenuOpen;
    joystick.style.display = state.isMobile && show ? "block" : "none";
    mobileActions.style.display = show ? "flex" : "none";
    pauseExitButton.style.display = state.running && !state.gameOver ? "block" : "none";
    updateDefenseHealButton();
    updateMobileSkillButtons();
    if (!show) {
      resetJoystick();
    }
  }

  function updateMobileSkillButtons() {
    const show = state.running && !state.paused && !state.gameOver;
    mobileStun.style.display = show && state.boosters.stun > 0 ? "block" : "none";
    mobileSpeed.style.display = show && state.boosters.speed > 0 ? "block" : "none";
    mobileDash.style.display = show && state.isMobile ? "block" : "none";
    mobileEject.style.display = show && state.isMobile ? "block" : "none";
    mobileStun.textContent = `STUN ${state.boosters.stun}`;
    mobileSpeed.textContent = `SPEED ${state.boosters.speed}`;
  }

  function isPlayerInsideDefenseCore() {
    const core = state.defense.core;
    const player = state.player;
    if (!core || !player) return false;
    return distance(player, core) < player.radius + core.radius;
  }

  function canUseDefenseHeal() {
    if (state.selectedMode !== "beer_defense" || !state.running || state.gameOver || state.pauseMenuOpen) return false;
    if (!isPlayerInsideDefenseCore()) return false;
    if (state.defense.healCooldown > 0) return false;
    return true;
  }

  function canHealDefenseCore() {
    if (!state.isMobile) return false;
    return canUseDefenseHeal();
  }

  function updateDefenseHealButton() {
    if (!state.isMobile || state.selectedMode !== "beer_defense" || !state.running || state.gameOver || state.pauseMenuOpen) {
      defenseHealButton.style.display = "none";
      defenseHealButton.classList.remove("cooldown");
      defenseHealButton.textContent = "Хил";
      return;
    }
    if (state.defense.healCooldown > 0) {
      defenseHealButton.style.display = "block";
      defenseHealButton.classList.add("cooldown");
      defenseHealButton.textContent = `Хил ${state.defense.healCooldown.toFixed(1)}с`;
      return;
    }
    if (isPlayerInsideDefenseCore()) {
      defenseHealButton.style.display = "block";
      defenseHealButton.classList.remove("cooldown");
      defenseHealButton.textContent = "Хил";
      return;
    }
    defenseHealButton.style.display = "none";
  }

  function updateDefenseHintBanner() {
    const show = !state.isMobile && state.selectedMode === "beer_defense" && state.running && !state.gameOver && !state.pauseMenuOpen && state.defense.hintTimer > 0;
    defenseHintBanner.style.display = show ? "block" : "none";
  }

  function triggerDefenseHeal() {
    if (!canUseDefenseHeal()) return;
    const core = state.defense.core;
    core.hp = Math.min(core.maxHp, core.hp + 5);
    state.defense.healCooldown = 2;
    updateHud();
  }

  function detectMobileControls() {
    const byTouch = window.matchMedia("(pointer: coarse)").matches;
    const byUA = /Android|iPhone|iPad|iPod|IEMobile|Opera Mini/i.test(navigator.userAgent);
    state.isMobile = byTouch || byUA;
    updateJoystickVisibility();
  }

  function setJoystickVector(clientX, clientY) {
    const rect = joystick.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    let dx = clientX - centerX;
    let dy = clientY - centerY;
    const dist = Math.hypot(dx, dy);
    const max = state.joystick.maxDist;
    if (dist > max && dist > 0) {
      dx = (dx / dist) * max;
      dy = (dy / dist) * max;
    }

    state.joystick.x = dx / max;
    state.joystick.y = dy / max;
    joystickStick.style.transform = `translate(${dx}px, ${dy}px)`;
  }

  function resetJoystick() {
    state.joystick.active = false;
    state.joystick.touchId = null;
    state.joystick.x = 0;
    state.joystick.y = 0;
    joystickStick.style.transform = "translate(0px, 0px)";
  }

  function selectMode(mode) {
    state.selectedMode = mode;
    modeCards.forEach((card) => {
      card.classList.toggle("active", card.dataset.mode === mode);
    });
    const showCoop = mode === "coop_online";
    coopControls.style.display = showCoop ? "flex" : "none";
    coopStatusRow.style.display = showCoop ? "flex" : "none";
    updateHud();
  }

  function isCoopMode() {
    return state.selectedMode === "coop_online";
  }

  function isCoopConnected() {
    return isCoopMode() && state.network.connected;
  }

  function isCoopHost() {
    return isCoopConnected() && state.network.id && state.network.hostId === state.network.id;
  }

  function isCoopClient() {
    return isCoopConnected() && !isCoopHost();
  }

  function setCoopStatus(text) {
    coopStatus.textContent = `Сеть: ${text}`;
  }

  function networkSend(payload) {
    if (!state.network.ws || state.network.ws.readyState !== WebSocket.OPEN) return;
    state.network.ws.send(JSON.stringify(payload));
  }

  function makeCoopPlayer(name = "Player") {
    const p = randomPoint();
    return {
      x: p.x,
      y: p.y,
      radius: 30,
      vx: 0,
      vy: 0,
      name
    };
  }

  function disconnectCoop() {
    if (state.network.ws) {
      state.network.ws.close();
    }
    state.network.ws = null;
    state.network.connected = false;
    state.network.id = null;
    state.network.hostId = null;
    state.coopPlayers = {};
    setCoopStatus("не подключено");
  }

  function handleCoopMessage(msg) {
    if (msg.type === "welcome") {
      state.network.id = msg.id;
      return;
    }

    if (msg.type === "room_state") {
      state.network.hostId = msg.hostId;
      if (isCoopHost()) {
        for (const peer of msg.peers || []) {
          if (peer.id !== state.network.id && !state.coopPlayers[peer.id]) {
            state.coopPlayers[peer.id] = makeCoopPlayer(peer.name || "Player");
          }
        }
      }
      setCoopStatus(isCoopHost() ? "подключено (хост)" : "подключено (клиент)");
      return;
    }

    if (msg.type === "peer_join") {
      if (isCoopHost() && msg.id !== state.network.id) {
        state.coopPlayers[msg.id] = makeCoopPlayer(msg.name || "Player");
      }
      return;
    }

    if (msg.type === "peer_leave") {
      delete state.coopPlayers[msg.id];
      return;
    }

    if (msg.type === "host_changed") {
      state.network.hostId = msg.hostId;
      setCoopStatus(isCoopHost() ? "подключено (хост)" : "подключено (клиент)");
      return;
    }

    if (msg.type === "input" && isCoopHost()) {
      if (!state.coopPlayers[msg.from]) {
        state.coopPlayers[msg.from] = makeCoopPlayer(msg.name || "Player");
      }
      if (msg.name) state.coopPlayers[msg.from].name = String(msg.name).slice(0, 24);
      state.coopPlayers[msg.from].inputX = Number(msg.x) || 0;
      state.coopPlayers[msg.from].inputY = Number(msg.y) || 0;
      return;
    }

    if (msg.type === "spawn_pellets" && isCoopHost() && state.running) {
      const mode = MODES[state.selectedMode];
      if (!Array.isArray(msg.pellets)) return;
      for (const p of msg.pellets) {
        if (state.pellets.length >= mode.pelletTarget) break;
        const x = Number(p.x);
        const y = Number(p.y);
        if (!Number.isFinite(x) || !Number.isFinite(y)) continue;
        spawnPellet(clamp(x, 0, WORLD.width), clamp(y, 0, WORLD.height), Boolean(p.bonus));
      }
      return;
    }

    if (msg.type === "eject_mass" && isCoopHost() && state.running) {
      state.coopEjectQueue.push({
        from: String(msg.from || ""),
        x: Number(msg.x) || 0,
        y: Number(msg.y) || 0
      });
      return;
    }

    if (msg.type === "snapshot" && isCoopClient()) {
      state.score = msg.score || 0;
      if (Array.isArray(msg.pellets)) state.pellets = msg.pellets;
      if (Array.isArray(msg.bots)) state.bots = msg.bots;
      if (Array.isArray(msg.powerups)) state.powerups = msg.powerups;

      const players = msg.players || {};
      const me = players[state.network.id];
      if (me) {
        if (!state.player) {
          state.player = { x: me.x, y: me.y, radius: me.radius, vx: me.vx || 0, vy: me.vy || 0, baseSpeed: 210 };
        } else {
          // Client-side smoothing: don't teleport each snapshot.
          state.player.x += (me.x - state.player.x) * 0.35;
          state.player.y += (me.y - state.player.y) * 0.35;
          state.player.vx = me.vx || 0;
          state.player.vy = me.vy || 0;
          state.player.radius = me.radius;
        }
      }

      const nextCoop = {};
      for (const [id, p] of Object.entries(players)) {
        if (id === state.network.id) continue;
        nextCoop[id] = {
          x: p.x, y: p.y, radius: p.radius, vx: p.vx || 0, vy: p.vy || 0, name: p.name || "Player"
        };
      }
      state.coopPlayers = nextCoop;
      return;
    }
  }

  function connectCoop() {
    disconnectCoop();
    state.network.url = coopUrlInput.value.trim() || COOP_WS_URL;
    coopUrlInput.value = state.network.url;
    state.network.room = coopRoomInput.value.trim() || "party";
    state.network.name = coopNameInput.value.trim() || "Player";

    try {
      const ws = new WebSocket(state.network.url);
      state.network.ws = ws;
      setCoopStatus("подключение...");

      ws.addEventListener("open", () => {
        state.network.connected = true;
        networkSend({
          type: "join",
          room: state.network.room,
          name: state.network.name
        });
      });

      ws.addEventListener("message", (event) => {
        try {
          const msg = JSON.parse(event.data);
          handleCoopMessage(msg);
        } catch {
          // Ignore invalid payloads.
        }
      });

      ws.addEventListener("close", () => {
        disconnectCoop();
      });

      ws.addEventListener("error", () => {
        setCoopStatus("ошибка подключения");
      });
    } catch {
      setCoopStatus("ошибка URL");
    }
  }

  function beginGame() {
    const mode = MODES[state.selectedMode];
    if (isCoopMode() && !state.network.connected) {
      alert("Сначала подключись к кооп-серверу.");
      return;
    }
    if (isCoopMode() && !state.network.hostId) {
      alert("Подожди инициализацию комнаты (1-2 секунды) и нажми Старт снова.");
      return;
    }

    state.running = true;
    state.paused = false;
    state.pauseMenuOpen = false;
    state.coopLocalPaused = false;
    state.gameOver = false;
    state.player = createPlayer();
    state.bots = [];
    state.pellets = [];
    state.powerups = [];
    state.score = 0;
    state.elapsed = 0;
    state.waveTimer = 0;
    state.spawnTimer = 0;
    state.powerupTimer = 0;
    state.boostTimer = 0;
    state.superSpeedTimer = 0;
    state.shieldTimer = 0;
    state.lastTime = performance.now();
    state.mouse.active = false;
    state.desktopPositionLock.enabled = false;
    state.coopPlayers = {};
    state.coopEjectQueue = [];
    state.coopSnapshotTimer = 0;
    state.coopInputSendTimer = 0;
    state.defense.core = null;
    state.defense.botSpawnTimer = 0;
    state.defense.wave = 1;
    state.defense.phase = "wave";
    state.defense.phaseTimer = 0;
    state.defense.healCooldown = 0;
    state.defense.hintTimer = 0;

    if (state.boosters.mass > 0) {
      state.player.radius *= 1.5;
      state.boosters.mass -= 1;
      saveBoosters();
    }

    if (state.selectedMode === "beer_defense") {
      state.defense.core = {
        x: WORLD.width / 2,
        y: WORLD.height / 2,
        radius: 52,
        hp: 1000,
        maxHp: 1000
      };
      if (!state.isMobile) {
        state.defense.hintTimer = 20;
      }
    }

    if (!isCoopMode() || isCoopHost()) {
      if (state.selectedMode === "beer_defense") {
        for (let i = 0; i < 4; i++) {
          spawnBotAroundDefenseCore();
        }
      }
      for (let i = 0; i < mode.startBots; i++) {
        spawnBot();
      }
      if (isCoopMode()) {
        for (let i = 0; i < mode.pelletTarget; i++) {
          const p = randomPoint();
          spawnPellet(p.x, p.y);
        }
      } else {
        // Make early game readable: most pellets appear near the player first.
        const nearCount = Math.floor(mode.pelletTarget * 0.7);
        for (let i = 0; i < nearCount; i++) {
          const p = randomPointNear(state.player, 650);
          spawnPellet(p.x, p.y);
        }
        for (let i = nearCount; i < mode.pelletTarget; i++) {
          spawnPellet();
        }
      }
    }

    menu.style.display = "none";
    gameOverPanel.style.display = "none";
    pauseMenu.style.display = "none";
    syncCamera();
    updateHud();
  }

  function finishGame(message, victory = false) {
    state.running = false;
    state.gameOver = true;
    state.pauseMenuOpen = false;
    state.coopLocalPaused = false;
    pauseMenu.style.display = "none";

    if (state.score > state.bestScores[state.selectedMode]) {
      state.bestScores[state.selectedMode] = Math.floor(state.score);
      saveBestScores();
    }

    gameOverTitle.textContent = victory ? "Отличный раунд" : "Игра окончена";
    gameOverText.textContent = `${message} Счёт: ${Math.floor(state.score)} | Рекорд: ${Math.floor(state.bestScores[state.selectedMode])}`;
    gameOverPanel.style.display = "grid";
    updateHud();
  }

  function openPauseMenu() {
    if (!state.running) return;
    if (isCoopMode()) {
      state.coopLocalPaused = true;
      state.paused = false;
    } else {
      state.paused = true;
    }
    state.pauseMenuOpen = true;
    pauseMenu.style.display = "grid";
    updateHud();
  }

  function closePauseMenu() {
    state.pauseMenuOpen = false;
    pauseMenu.style.display = "none";
  }

  function continueFromPauseMenu() {
    if (!state.pauseMenuOpen) return;
    closePauseMenu();
    state.paused = false;
    state.coopLocalPaused = false;
    updateHud();
  }

  function exitFromPauseMenu() {
    if (!state.pauseMenuOpen) return;
    const finalScore = Math.max(0, Math.floor(state.score));
    if (finalScore > state.bestScores[state.selectedMode]) {
      state.bestScores[state.selectedMode] = finalScore;
      saveBestScores();
    }
    state.boosterPoints += finalScore;
    saveBoosterPoints();
    state.running = false;
    state.paused = false;
    state.coopLocalPaused = false;
    state.gameOver = false;
    closePauseMenu();
    gameOverPanel.style.display = "none";
    menu.style.display = "grid";
    updateHud();
  }

  function distance(a, b) {
    const dx = a.x - b.x;
    const dy = a.y - b.y;
    return Math.sqrt(dx * dx + dy * dy);
  }

  function clamp(v, min, max) {
    return Math.max(min, Math.min(max, v));
  }

  function agarSpeedForRadius(radius, speedFactor = 1) {
    const base = 360 / Math.pow(Math.max(12, radius), 0.35);
    return clamp(base * speedFactor, 52, 260);
  }

  function applyEntityPhysics(entity, targetDirX, targetDirY, dt, speedFactor = 1) {
    const targetSpeed = agarSpeedForRadius(entity.radius, speedFactor);
    const targetVx = targetDirX * targetSpeed;
    const targetVy = targetDirY * targetSpeed;
    const response = clamp(8.5 * dt, 0.08, 0.45);
    entity.vx += (targetVx - entity.vx) * response;
    entity.vy += (targetVy - entity.vy) * response;

    entity.x += entity.vx * dt;
    entity.y += entity.vy * dt;

    const minX = entity.radius;
    const maxX = WORLD.width - entity.radius;
    const minY = entity.radius;
    const maxY = WORLD.height - entity.radius;

    if (entity.x < minX) {
      entity.x = minX;
      entity.vx *= -0.18;
    } else if (entity.x > maxX) {
      entity.x = maxX;
      entity.vx *= -0.18;
    }

    if (entity.y < minY) {
      entity.y = minY;
      entity.vy *= -0.18;
    } else if (entity.y > maxY) {
      entity.y = maxY;
      entity.vy *= -0.18;
    }
  }

  function applyAgarSoftCollisions() {
    if (!state.player) return;
    const entities = [state.player, ...Object.values(state.coopPlayers), ...state.bots];
    for (let i = 0; i < entities.length; i++) {
      for (let j = i + 1; j < entities.length; j++) {
        const a = entities[i];
        const b = entities[j];
        const dx = b.x - a.x;
        const dy = b.y - a.y;
        const dist = Math.hypot(dx, dy) || 0.0001;
        const minDist = a.radius + b.radius;
        if (dist >= minDist) continue;
        if (a.radius > b.radius * 1.07 || b.radius > a.radius * 1.07) continue;

        const overlap = minDist - dist;
        const nx = dx / dist;
        const ny = dy / dist;
        const totalMass = a.radius + b.radius;
        const aPush = (b.radius / totalMass) * overlap;
        const bPush = (a.radius / totalMass) * overlap;

        a.x -= nx * aPush;
        a.y -= ny * aPush;
        b.x += nx * bPush;
        b.y += ny * bPush;

        a.vx -= nx * 8;
        a.vy -= ny * 8;
        b.vx += nx * 8;
        b.vy += ny * 8;
      }
    }
  }

  function applyPelletMagnet(dt) {
    if (!state.experimental.pelletMagnet || !state.player) return;
    const p = state.player;
    for (const pellet of state.pellets) {
      const dx = p.x - pellet.x;
      const dy = p.y - pellet.y;
      const d = Math.hypot(dx, dy);
      if (d < 1 || d > 180) continue;
      const pull = (1 - d / 180) * (95 * dt);
      pellet.x += (dx / d) * pull;
      pellet.y += (dy / d) * pull;
    }
  }

  function openExperimentalMenu() {
    expMagnet.checked = state.experimental.pelletMagnet;
    experimentalMenu.style.display = "grid";
  }

  function activateStunBooster() {
    if (!state.running || state.paused || state.pauseMenuOpen || state.boosters.stun <= 0 || !state.bots.length) return;
    let nearest = null;
    let bestDist = Infinity;
    for (const bot of state.bots) {
      const d = distance(state.player, bot);
      if (d < bestDist) {
        bestDist = d;
        nearest = bot;
      }
    }
    if (!nearest) return;
    nearest.stunTimer = 10;
    state.boosters.stun -= 1;
    saveBoosters();
    updateBoosterPanel();
  }

  function activateSpeedBooster() {
    if (!state.running || state.paused || state.pauseMenuOpen || state.boosters.speed <= 0) return;
    state.superSpeedTimer = Math.max(state.superSpeedTimer, 5);
    state.boosters.speed -= 1;
    saveBoosters();
    updateBoosterPanel();
  }

  function movePlayer(dt) {
    const player = state.player;
    if (!player) return;

    if (isCoopMode() && state.coopLocalPaused) {
      player.vx = 0;
      player.vy = 0;
      state.coopInput.x = 0;
      state.coopInput.y = 0;
      return;
    }

    if (!state.isMobile && state.desktopPositionLock.enabled && state.selectedMode !== "beer_defense") {
      player.x = state.desktopPositionLock.x;
      player.y = state.desktopPositionLock.y;
      player.vx = 0;
      player.vy = 0;
      state.coopInput.x = 0;
      state.coopInput.y = 0;
      return;
    }

    let mx = 0;
    let my = 0;

    if (state.keys.has("ArrowUp") || state.keys.has("w")) my -= 1;
    if (state.keys.has("ArrowDown") || state.keys.has("s")) my += 1;
    if (state.keys.has("ArrowLeft") || state.keys.has("a")) mx -= 1;
    if (state.keys.has("ArrowRight") || state.keys.has("d")) mx += 1;

    if (mx === 0 && my === 0 && state.joystick.active) {
      mx = state.joystick.x;
      my = state.joystick.y;
    }

    if (mx === 0 && my === 0 && state.mouse.active) {
      const worldMouse = screenToWorld(state.mouse.x, state.mouse.y);
      mx = worldMouse.x - player.x;
      my = worldMouse.y - player.y;
    }

    const len = Math.hypot(mx, my);
    if (len > 0.0001) {
      mx /= len;
      my /= len;
    }
    state.coopInput.x = mx;
    state.coopInput.y = my;

    let speedFactor = 1;
    if (state.boostTimer > 0) speedFactor *= 1.28;
    if (state.superSpeedTimer > 0) speedFactor *= 3;
    applyEntityPhysics(player, mx, my, dt, speedFactor);

    if (isCoopClient()) {
      // Client prediction keeps movement responsive on latency.
      return;
    }
  }

  function moveCoopPlayersHost(dt) {
    if (!isCoopHost()) return;
    for (const p of Object.values(state.coopPlayers)) {
      const inputX = Number(p.inputX) || 0;
      const inputY = Number(p.inputY) || 0;
      const len = Math.hypot(inputX, inputY);
      const mx = len > 0.0001 ? inputX / len : 0;
      const my = len > 0.0001 ? inputY / len : 0;
      applyEntityPhysics(p, mx, my, dt, 1);
    }
  }

  function botSteerTarget(bot) {
    const player = state.player;
    if (!player) return { x: bot.x, y: bot.y, mood: "idle" };

    if (state.selectedMode === "beer_defense" && state.defense.core) {
      const core = state.defense.core;
      return { x: core.x, y: core.y, mood: "assault" };
    }

    const distToPlayer = distance(bot, player);
    if (bot.radius > player.radius * 1.08 && distToPlayer < 360) {
      return { x: player.x, y: player.y, mood: "hunt" };
    }

    if (player.radius > bot.radius * 1.2 && distToPlayer < 250) {
      return {
        x: bot.x - (player.x - bot.x),
        y: bot.y - (player.y - bot.y),
        mood: "flee"
      };
    }

    let nearest = null;
    let nearestDist = Infinity;
    for (const pellet of state.pellets) {
      const d = distance(bot, pellet);
      if (d < nearestDist) {
        nearestDist = d;
        nearest = pellet;
      }
    }

    if (nearest) {
      return { x: nearest.x, y: nearest.y, mood: "farm" };
    }
    return { x: player.x, y: player.y, mood: "drift" };
  }

  function moveBots(dt) {
    const mode = MODES[state.selectedMode];
    for (const bot of state.bots) {
      bot.stunTimer = Math.max(0, (bot.stunTimer || 0) - dt);
      if (bot.stunTimer > 0) {
        bot.vx *= 0.9;
        bot.vy *= 0.9;
        bot.x += bot.vx * dt;
        bot.y += bot.vy * dt;
        continue;
      }
      const target = botSteerTarget(bot);
      const dx = target.x - bot.x;
      const dy = target.y - bot.y;
      const len = Math.hypot(dx, dy) || 1;
      const dirX = dx / len;
      const dirY = dy / len;

      const moodMult = target.mood === "hunt" ? 1.08 : target.mood === "flee" ? 1.17 : target.mood === "assault" ? 1.14 : 0.95;
      const modeFactor = mode.botBaseSpeed / 112;
      const defenseSpeed = state.selectedMode === "beer_defense" ? getDefenseWaveParams(state.defense.wave).speedMult : 1;
      applyEntityPhysics(bot, dirX, dirY, dt, moodMult * modeFactor * defenseSpeed);
    }
  }

  function handlePelletEats(dt) {
    const player = state.player;
    for (let i = state.pellets.length - 1; i >= 0; i--) {
      const pellet = state.pellets[i];
      if (distance(player, pellet) < player.radius + pellet.radius) {
        let gain = Number(pellet.massGain) || 0.75;
        if (state.selectedMode === "beer_defense") {
          gain *= 0.45;
        }
        player.radius += gain;
        if (pellet.kind !== "ejected") {
          state.score += pellet.value;
        }
        state.pellets.splice(i, 1);
      }
    }

    for (const bot of state.bots) {
      for (let i = state.pellets.length - 1; i >= 0; i--) {
        const pellet = state.pellets[i];
        if (distance(bot, pellet) < bot.radius + pellet.radius) {
          const gain = Number(pellet.massGain) || 0.55;
          bot.radius += Math.max(0.4, gain * 0.8);
          state.pellets.splice(i, 1);
        }
      }
      // Removed bot passive mass decay by request.
    }

    // Removed player passive mass decay by request.
  }

  function handleCoopPelletEatsHost() {
    if (!isCoopHost()) return;
    for (const ally of Object.values(state.coopPlayers)) {
      for (let i = state.pellets.length - 1; i >= 0; i--) {
        const pellet = state.pellets[i];
        if (distance(ally, pellet) < ally.radius + pellet.radius) {
          const gain = Number(pellet.massGain) || 0.75;
          ally.radius += gain;
          if (pellet.kind !== "ejected") {
            state.score += pellet.value;
          }
          state.pellets.splice(i, 1);
        }
      }
    }
  }

  function resolveEntityEat(eater, victim, factor = 0.28) {
    eater.radius += victim.radius * factor;
  }

  function handleBotVsPlayer() {
    const player = state.player;
    for (let i = state.bots.length - 1; i >= 0; i--) {
      const bot = state.bots[i];
      const d = distance(bot, player);
      const canTouch = d < Math.max(bot.radius, player.radius) * 0.92;
      if (!canTouch) continue;

      if (player.radius > bot.radius * 1.07) {
        const gainFactor = state.selectedMode === "beer_defense" ? 0.036 : 0.32;
        resolveEntityEat(player, bot, gainFactor);
        state.bots.splice(i, 1);
        state.score += 125;
        if (state.selectedMode !== "beer_defense") {
          setTimeout(() => {
            if (state.running) spawnBot(2 + Math.random() * 6);
          }, 900);
        }
      } else if (bot.radius > player.radius * 1.07) {
        if (state.shieldTimer > 0) {
          bot.x += (bot.x - player.x) * 0.15;
          bot.y += (bot.y - player.y) * 0.15;
          bot.radius = Math.max(12, bot.radius - 2.5);
        } else {
          finishGame("Тебя поглотил бот.");
          return;
        }
      }
    }
  }

  function handleDefenseCore(dt) {
    if (state.selectedMode !== "beer_defense") return;
    const core = state.defense.core;
    if (!core) return;

    let attackers = 0;
    for (const bot of state.bots) {
      const d = distance(bot, core);
      if (d < bot.radius + core.radius * 0.92) {
        attackers += 1;
      }
    }

    if (attackers > 0) {
      const damagePerSecondPerBot = 19;
      core.hp = Math.max(0, core.hp - attackers * damagePerSecondPerBot * dt);
      if (core.hp <= 0) {
        finishGame("Ядро пива уничтожено. Оборона провалена.");
      }
    }
  }

  function handleBotVsCoopHost() {
    if (!isCoopHost()) return;
    const players = [state.player, ...Object.values(state.coopPlayers)];
    for (const targetPlayer of players) {
      for (let i = state.bots.length - 1; i >= 0; i--) {
        const bot = state.bots[i];
        const d = distance(bot, targetPlayer);
        if (d >= Math.max(bot.radius, targetPlayer.radius) * 0.92) continue;

        if (targetPlayer.radius > bot.radius * 1.07) {
          resolveEntityEat(targetPlayer, bot, 0.32);
          state.bots.splice(i, 1);
          state.score += 110;
          if (state.selectedMode !== "beer_defense") {
            setTimeout(() => {
              if (state.running) spawnBot(2 + Math.random() * 6);
            }, 900);
          }
        } else if (bot.radius > targetPlayer.radius * 1.07) {
          targetPlayer.radius = 30;
          const resp = randomPoint();
          targetPlayer.x = resp.x;
          targetPlayer.y = resp.y;
          targetPlayer.vx = 0;
          targetPlayer.vy = 0;
        }
      }
    }
  }

  function sendCoopSnapshot(dt) {
    if (!isCoopHost()) return;
    state.coopSnapshotTimer += dt;
    if (state.coopSnapshotTimer < 0.12) return;
    state.coopSnapshotTimer = 0;

    const players = {};
    players[state.network.id] = {
      x: state.player.x,
      y: state.player.y,
      radius: state.player.radius,
      vx: state.player.vx || 0,
      vy: state.player.vy || 0,
      name: state.network.name
    };
    for (const [id, p] of Object.entries(state.coopPlayers)) {
      players[id] = {
        x: p.x, y: p.y, radius: p.radius, vx: p.vx || 0, vy: p.vy || 0, name: p.name || "Player"
      };
    }

    networkSend({
      type: "snapshot",
      score: state.score,
      // Send heavy lists less frequently to reduce lag on weak connections.
      pellets: state.pellets,
      bots: state.bots,
      powerups: state.powerups,
      players
    });
  }

  function handlePowerups(dt) {
    for (let i = state.powerups.length - 1; i >= 0; i--) {
      const p = state.powerups[i];
      p.life -= dt;
      if (p.life <= 0) {
        state.powerups.splice(i, 1);
        continue;
      }

      if (distance(state.player, p) < state.player.radius + p.radius) {
        if (p.type === "boost") {
          state.boostTimer = 5;
          state.score += 35;
        } else {
          state.shieldTimer = 6;
          state.score += 25;
        }
        state.powerups.splice(i, 1);
      }
    }

    state.boostTimer = Math.max(0, state.boostTimer - dt);
    state.superSpeedTimer = Math.max(0, state.superSpeedTimer - dt);
    state.shieldTimer = Math.max(0, state.shieldTimer - dt);
  }

  function modeLogic(dt) {
    const mode = MODES[state.selectedMode];

    state.defense.healCooldown = Math.max(0, state.defense.healCooldown - dt);
    state.defense.hintTimer = Math.max(0, state.defense.hintTimer - dt);

    if (state.selectedMode === "beer_defense") {
      const waveParams = getDefenseWaveParams(state.defense.wave);
      state.defense.phaseTimer += dt;

      const playerRadius = state.player ? state.player.radius : 34;
      const desiredBotRadius = Math.max(waveParams.minRadius, playerRadius * waveParams.targetPlayerScale);
      for (const bot of state.bots) {
        if (bot.radius < desiredBotRadius) {
          bot.radius = Math.min(desiredBotRadius, bot.radius + dt * 0.62);
        } else if (bot.radius > desiredBotRadius * 1.12) {
          bot.radius = Math.max(desiredBotRadius, bot.radius - dt * 0.05);
        }
      }

      if (state.defense.phase === "wave") {
        state.defense.botSpawnTimer += dt;
        const canSpawn = state.defense.phaseTimer < 60;
        if (canSpawn && state.defense.botSpawnTimer >= waveParams.spawnInterval) {
          state.defense.botSpawnTimer = 0;
          if (state.bots.length < waveParams.maxBots) {
            spawnBotAroundDefenseCore(waveParams.spawnBoost);
          }
        }

        const waveTimeDone = state.defense.phaseTimer >= 60;
        const allBotsCleared = state.bots.length === 0;
        if (waveTimeDone && allBotsCleared) {
          state.defense.phase = "break";
          state.defense.phaseTimer = 0;
          state.defense.botSpawnTimer = 0;
        }
      } else {
        if (state.defense.phaseTimer >= 15) {
          state.defense.phase = "wave";
          state.defense.wave += 1;
          state.defense.phaseTimer = 0;
          state.defense.botSpawnTimer = 0;
          const nextWaveParams = getDefenseWaveParams(state.defense.wave);
          for (let i = 0; i < Math.min(4 + state.defense.wave, 10); i++) {
            spawnBotAroundDefenseCore(nextWaveParams.spawnBoost);
          }
        }
      }

      if (state.defense.core) {
        state.score += dt * 6;
      }
    }

    if (mode.scoreFromTime) {
      state.score += 14 * dt;
    }

    if (mode.waveEvery) {
      state.waveTimer += dt;
      if (state.waveTimer >= mode.waveEvery) {
        state.waveTimer = 0;
        spawnBot(3 + Math.random() * 7);
        state.score += 40;
      }
    }

    if (state.selectedMode === "survival" && state.bots.length < 2) {
      spawnBot(2 + Math.random() * 5);
    }

    if (mode.duration !== null) {
      const remain = Math.max(0, mode.duration - state.elapsed);
      statusLine.textContent = `Статус: осталось ${remain.toFixed(1)}с`;
      if (remain <= 0) {
        finishGame("Время вышло. Отличная попытка!", true);
      }
    }
  }

  function spawnSystems(dt) {
    const mode = MODES[state.selectedMode];
    state.spawnTimer += dt;
    state.powerupTimer += dt;

    const spawnInterval = isCoopMode() ? 0.018 : 0.03;
    const spawnBurst = isCoopMode() ? 2 : 1;
    if (state.pellets.length < mode.pelletTarget && state.spawnTimer > spawnInterval) {
      state.spawnTimer = 0;
      for (let n = 0; n < spawnBurst && state.pellets.length < mode.pelletTarget; n++) {
        if (isCoopMode()) {
          if (Math.random() < 0.8) {
            const p = randomPointNearAnyCoopPlayer(900);
            spawnPellet(p.x, p.y);
          } else {
            spawnPellet();
          }
        } else {
          if (Math.random() < 0.75) {
            const p = randomPointNear(state.player, 800);
            spawnPellet(p.x, p.y);
          } else {
            spawnPellet();
          }
        }
      }
      if (Math.random() < (isCoopMode() ? 0.12 : 0.08)) {
        const b = isCoopMode() ? randomPointNearAnyCoopPlayer(1000) : randomPointNear(state.player, 900);
        spawnPellet(b.x, b.y, true);
      }
    }

    if (state.powerupTimer > 9.5 && state.powerups.length < 2) {
      state.powerupTimer = 0;
      spawnPowerup();
    }
  }

  function spawnEjectedMass(x, y, massAmount) {
    const gain = Math.max(0.6, Number(massAmount) || 0.6);
    state.pellets.push({
      x,
      y,
      radius: clamp(7 + gain * 1.7, 8, 16),
      value: Math.round(gain * 20),
      massGain: gain,
      kind: "ejected",
      color: "#ff9f43"
    });
  }

  function ejectMassForEntity(entity, dirX, dirY) {
    if (!entity || entity.radius <= 16) return false;
    const massOut = clamp(entity.radius * 0.07, 1.2, 3.2);
    entity.radius -= massOut;
    const len = Math.hypot(dirX, dirY);
    const nx = len > 0.001 ? dirX / len : Math.cos(Math.random() * Math.PI * 2);
    const ny = len > 0.001 ? dirY / len : Math.sin(Math.random() * Math.PI * 2);
    const x = clamp(entity.x + nx * (entity.radius + 20), 0, WORLD.width);
    const y = clamp(entity.y + ny * (entity.radius + 20), 0, WORLD.height);
    spawnEjectedMass(x, y, massOut);
    return true;
  }

  function processCoopEjectQueueHost() {
    if (!isCoopHost() || !state.coopEjectQueue.length) return;
    const maxPerTick = 8;
    for (let i = 0; i < maxPerTick && state.coopEjectQueue.length; i++) {
      const req = state.coopEjectQueue.shift();
      const entity = req.from === state.network.id ? state.player : state.coopPlayers[req.from];
      if (!entity) continue;
      ejectMassForEntity(entity, req.x, req.y);
    }
  }

  function triggerEjectMassAction() {
    if (!state.running || state.paused || state.pauseMenuOpen || !state.player) return;

    if (isCoopMode()) {
      networkSend({
        type: "eject_mass",
        x: state.coopInput.x || 0,
        y: state.coopInput.y || 0,
        name: state.network.name
      });
      return;
    }

    const worldMouse = screenToWorld(state.mouse.x, state.mouse.y);
    if (ejectMassForEntity(state.player, worldMouse.x - state.player.x, worldMouse.y - state.player.y)) {
      state.score = Math.max(0, state.score - 8);
    }
  }

  function drawBackground() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    const grad = ctx.createLinearGradient(0, 0, canvas.width, canvas.height);
    grad.addColorStop(0, "#0e2438");
    grad.addColorStop(0.5, "#163b56");
    grad.addColorStop(1, "#0b1728");
    ctx.fillStyle = grad;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const zoom = state.camera.zoom || 1;
    const visibleWorldWidth = canvas.width / zoom;
    const visibleWorldHeight = canvas.height / zoom;

    ctx.strokeStyle = "rgba(255,255,255,0.06)";
    ctx.lineWidth = 1;
    const step = WORLD.gridStep;
    const firstGridX = Math.floor(state.camera.x / step) * step;
    const firstGridY = Math.floor(state.camera.y / step) * step;
    for (let x = firstGridX; x <= state.camera.x + visibleWorldWidth; x += step) {
      const sx = toScreenX(x);
      ctx.beginPath();
      ctx.moveTo(sx, 0);
      ctx.lineTo(sx, canvas.height);
      ctx.stroke();
    }
    for (let y = firstGridY; y <= state.camera.y + visibleWorldHeight; y += step) {
      const sy = toScreenY(y);
      ctx.beginPath();
      ctx.moveTo(0, sy);
      ctx.lineTo(canvas.width, sy);
      ctx.stroke();
    }

    const worldX = toScreenX(0);
    const worldY = toScreenY(0);
    ctx.strokeStyle = "rgba(255,255,255,0.42)";
    ctx.lineWidth = clamp(2, 5 * zoom, 5);
    ctx.strokeRect(worldX, worldY, WORLD.width * zoom, WORLD.height * zoom);
  }

  function drawCircleEntity(entity, color, label = "") {
    const sx = toScreenX(entity.x);
    const sy = toScreenY(entity.y);
    const sr = toScreenRadius(entity.radius);
    ctx.beginPath();
    ctx.arc(sx, sy, sr, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
    ctx.lineWidth = clamp(1, 2 * (state.camera.zoom || 1), 2);
    ctx.strokeStyle = "rgba(255,255,255,0.25)";
    ctx.stroke();

    if (label) {
      ctx.fillStyle = "rgba(255,255,255,0.9)";
      ctx.font = `bold ${clamp(9, 11 * (state.camera.zoom || 1), 14)}px Segoe UI`;
      ctx.textAlign = "center";
      ctx.fillText(label, sx, sy + clamp(3, 4 * (state.camera.zoom || 1), 5));
    }
  }

  function drawPlayer() {
    const p = state.player;
    if (!p) return;

    const px = toScreenX(p.x);
    const py = toScreenY(p.y);
    const pr = toScreenRadius(p.radius);

    if (state.shieldTimer > 0) {
      ctx.beginPath();
      ctx.arc(px, py, pr + toScreenRadius(7 + Math.sin(state.elapsed * 8) * 1.5), 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(125, 209, 255, 0.75)";
      ctx.lineWidth = clamp(2, 4 * (state.camera.zoom || 1), 4);
      ctx.stroke();
    }

    ctx.save();
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI * 2);
    ctx.clip();

    if ((hasCustomImage || (playerImage.complete && playerImage.naturalWidth > 0))) {
      ctx.drawImage(playerImage, px - pr, py - pr, pr * 2, pr * 2);
    } else {
      const g = ctx.createRadialGradient(px - pr * 0.4, py - pr * 0.5, pr * 0.2, px, py, pr);
      g.addColorStop(0, "#9ef8dd");
      g.addColorStop(1, "#36c99a");
      ctx.fillStyle = g;
      ctx.fillRect(px - pr, py - pr, pr * 2, pr * 2);
    }

    ctx.restore();
    ctx.beginPath();
    ctx.arc(px, py, pr, 0, Math.PI * 2);
    ctx.lineWidth = clamp(1, 2 * (state.camera.zoom || 1), 2);
    ctx.strokeStyle = "rgba(255,255,255,0.35)";
    ctx.stroke();
  }

  function drawPellets() {
    const beerMode = state.selectedMode === "beer_party";
    for (const pellet of state.pellets) {
      const sx = toScreenX(pellet.x);
      const sy = toScreenY(pellet.y);
      const sr = toScreenRadius(pellet.radius);
      if (beerMode && pellet.kind === "normal" && pelletImage.complete && pelletImage.naturalWidth > 0) {
        const size = sr * 2.8;
        ctx.drawImage(pelletImage, sx - size / 2, sy - size / 2, size, size);
        continue;
      }
      ctx.beginPath();
      ctx.arc(sx, sy, sr, 0, Math.PI * 2);
      ctx.fillStyle = pellet.color;
      ctx.fill();
    }
  }

  function drawDefenseCore() {
    if (state.selectedMode !== "beer_defense" || !state.defense.core) return;
    const core = state.defense.core;
    const sx = toScreenX(core.x);
    const sy = toScreenY(core.y);
    const sr = toScreenRadius(core.radius);

    ctx.save();
    ctx.beginPath();
    ctx.arc(sx, sy, sr, 0, Math.PI * 2);
    ctx.clip();
    if (pelletImage.complete && pelletImage.naturalWidth > 0) {
      ctx.drawImage(pelletImage, sx - sr, sy - sr, sr * 2, sr * 2);
    } else {
      ctx.fillStyle = "#ffcd5f";
      ctx.fillRect(sx - sr, sy - sr, sr * 2, sr * 2);
    }
    ctx.restore();

    ctx.beginPath();
    ctx.arc(sx, sy, sr, 0, Math.PI * 2);
    ctx.lineWidth = clamp(1, 3 * (state.camera.zoom || 1), 3);
    ctx.strokeStyle = "rgba(255,255,255,0.6)";
    ctx.stroke();

    const hpRatio = core.maxHp > 0 ? core.hp / core.maxHp : 0;
    const barW = sr * 2.2;
    const barH = Math.max(6, sr * 0.16);
    const bx = sx - barW / 2;
    const by = sy - sr - barH - 12;
    ctx.fillStyle = "rgba(0, 0, 0, 0.45)";
    ctx.fillRect(bx, by, barW, barH);
    ctx.fillStyle = hpRatio > 0.45 ? "#4dd7a8" : hpRatio > 0.2 ? "#ffd166" : "#ff6b6b";
    ctx.fillRect(bx, by, barW * clamp(hpRatio, 0, 1), barH);
    ctx.strokeStyle = "rgba(255,255,255,0.5)";
    ctx.lineWidth = 1;
    ctx.strokeRect(bx, by, barW, barH);
  }

  function drawPowerups() {
    for (const p of state.powerups) {
      const color = p.type === "boost" ? "#ff9f43" : "#8fd3ff";
      drawCircleEntity(p, color, p.type === "boost" ? "B" : "S");
    }
  }

  function drawBots() {
    for (const bot of state.bots) {
      drawCircleEntity(bot, bot.color);
    }
  }

  function drawCoopPlayers() {
    for (const p of Object.values(state.coopPlayers)) {
      const nick = p.name && p.name.trim() ? p.name.trim() : "Player";
      drawCircleEntity(p, "#63b3ff", nick);
    }
  }

  function render() {
    drawBackground();
    if (!state.player) return;
    drawPellets();
    drawDefenseCore();
    drawPowerups();
    drawBots();
    if (isCoopMode()) {
      drawCoopPlayers();
    }
    drawPlayer();
  }

  function tick(now) {
    const dt = Math.min(0.05, (now - state.lastTime) / 1000);
    state.lastTime = now;

    if (state.running && !state.paused) {
      state.elapsed += dt;
      movePlayer(dt);
      if (isCoopMode()) {
        if (isCoopHost()) {
          moveCoopPlayersHost(dt);
          moveBots(dt);
          applyAgarSoftCollisions();
          applyPelletMagnet(dt);
          processCoopEjectQueueHost();
          handlePelletEats(dt);
          handleCoopPelletEatsHost();
          handlePowerups(dt);
          handleDefenseCore(dt);
          handleBotVsCoopHost();
          modeLogic(dt);
          sendCoopSnapshot(dt);
        } else if (isCoopClient()) {
          state.coopInputSendTimer += dt;
          if (state.coopInputSendTimer >= 0.033) {
            state.coopInputSendTimer = 0;
            networkSend({
              type: "input",
              x: state.coopInput.x,
              y: state.coopInput.y,
              name: state.network.name
            });
          }
        }
      } else {
        moveBots(dt);
        applyAgarSoftCollisions();
        applyPelletMagnet(dt);
        spawnSystems(dt);
        handlePelletEats(dt);
        handlePowerups(dt);
        handleDefenseCore(dt);
        handleBotVsPlayer();
        if (state.running) {
          modeLogic(dt);
        }
      }
      syncCamera();
      updateHud();
    }

    render();
    requestAnimationFrame(tick);
  }

  window.addEventListener("resize", resizeCanvas);
  window.addEventListener("resize", detectMobileControls);
  document.addEventListener("visibilitychange", () => {
    if (document.hidden && state.running && !state.pauseMenuOpen) {
      openPauseMenu();
    }
  });
  window.addEventListener("blur", () => {
    if (state.running && !state.pauseMenuOpen) {
      openPauseMenu();
    }
  });

  window.addEventListener("mousemove", (event) => {
    state.mouse.x = event.clientX;
    state.mouse.y = event.clientY;
    state.mouse.active = true;
  });

  canvas.addEventListener("mousedown", (event) => {
    if (event.button !== 1 || state.isMobile || !state.player) return;
    if (state.selectedMode === "beer_defense") {
      event.preventDefault();
      triggerDefenseHeal();
      return;
    }
    event.preventDefault();
    state.desktopPositionLock.enabled = !state.desktopPositionLock.enabled;
    if (state.desktopPositionLock.enabled) {
      state.desktopPositionLock.x = state.player.x;
      state.desktopPositionLock.y = state.player.y;
    }
    updateHud();
  });

  joystick.addEventListener("touchstart", (event) => {
    const t = event.changedTouches[0];
    state.joystick.active = true;
    state.joystick.touchId = t.identifier;
    setJoystickVector(t.clientX, t.clientY);
    event.preventDefault();
  }, { passive: false });

  joystick.addEventListener("touchmove", (event) => {
    for (const t of event.changedTouches) {
      if (t.identifier === state.joystick.touchId) {
        setJoystickVector(t.clientX, t.clientY);
        event.preventDefault();
        break;
      }
    }
  }, { passive: false });

  joystick.addEventListener("touchend", (event) => {
    for (const t of event.changedTouches) {
      if (t.identifier === state.joystick.touchId) {
        if (state.selectedMode === "beer_defense" && state.isMobile && state.running && !state.pauseMenuOpen) {
          state.joystick.touchId = null;
          state.joystick.active = true;
        } else {
          resetJoystick();
        }
        event.preventDefault();
        break;
      }
    }
  }, { passive: false });

  joystick.addEventListener("touchcancel", () => {
    if (state.selectedMode === "beer_defense" && state.isMobile && state.running && !state.pauseMenuOpen) {
      state.joystick.touchId = null;
      state.joystick.active = true;
      return;
    }
    resetJoystick();
  }, { passive: true });

  mobileEject.addEventListener("touchstart", (event) => {
    triggerEjectMassAction();
    event.preventDefault();
  }, { passive: false });

  mobileEject.addEventListener("click", () => {
    triggerEjectMassAction();
  });

  mobileStun.addEventListener("touchstart", (event) => {
    activateStunBooster();
    event.preventDefault();
  }, { passive: false });

  mobileStun.addEventListener("click", () => {
    activateStunBooster();
  });

  mobileSpeed.addEventListener("touchstart", (event) => {
    activateSpeedBooster();
    event.preventDefault();
  }, { passive: false });

  mobileSpeed.addEventListener("click", () => {
    activateSpeedBooster();
  });

  mobileDash.addEventListener("touchstart", (event) => {
    state.boostTimer = Math.max(state.boostTimer, 1.2);
    event.preventDefault();
  }, { passive: false });

  mobileDash.addEventListener("click", () => {
    state.boostTimer = Math.max(state.boostTimer, 1.2);
  });

  defenseHealButton.addEventListener("touchstart", (event) => {
    triggerDefenseHeal();
    event.preventDefault();
  }, { passive: false });

  defenseHealButton.addEventListener("click", () => {
    triggerDefenseHeal();
  });

  window.addEventListener("keydown", (event) => {
    const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;

    if (key === "p") {
      if (state.running) {
        if (state.pauseMenuOpen) {
          continueFromPauseMenu();
        } else {
          openPauseMenu();
        }
      }
      return;
    }

    if (key === "q" || key === "й") {
      triggerEjectMassAction();
      return;
    }

    if (key === "Shift") {
      if (state.pauseMenuOpen) return;
      state.boostTimer = Math.max(state.boostTimer, 1.2);
    }

    state.keys.add(key);
  });

  window.addEventListener("keyup", (event) => {
    const key = event.key.length === 1 ? event.key.toLowerCase() : event.key;
    state.keys.delete(key);
  });

  playerImageInput.addEventListener("change", (e) => {
    const file = e.target.files && e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      playerImage.src = ev.target.result;
      hasCustomImage = true;
    };
    reader.readAsDataURL(file);
  });

  modeCards.forEach((card) => {
    card.addEventListener("click", () => selectMode(card.dataset.mode));
  });

  playButton.addEventListener("click", beginGame);
  retryButton.addEventListener("click", beginGame);

  openBoosterShopButton.addEventListener("click", () => {
    const isOpen = boosterPanel.style.display === "block";
    boosterPanel.style.display = isOpen ? "none" : "block";
    updateBoosterPanel();
  });

  buyStunButton.addEventListener("click", () => buyBooster("stun", 1500, 3));
  buySpeedButton.addEventListener("click", () => buyBooster("speed", 1500, 2));
  buyMassButton.addEventListener("click", () => buyBooster("mass", 2000, 1));
  pauseExitButton.addEventListener("click", openPauseMenu);
  pauseContinueButton.addEventListener("click", continueFromPauseMenu);
  pauseExitMenuButton.addEventListener("click", exitFromPauseMenu);

  backMenuButton.addEventListener("click", () => {
    state.running = false;
    state.paused = false;
    state.pauseMenuOpen = false;
    state.coopLocalPaused = false;
    gameOverPanel.style.display = "none";
    pauseMenu.style.display = "none";
    menu.style.display = "grid";
    updateHud();
  });

  clearBestButton.addEventListener("click", () => {
    if (state.clearBestClickTimer) {
      clearTimeout(state.clearBestClickTimer);
      state.clearBestClickTimer = null;
      openExperimentalMenu();
      return;
    }
    state.clearBestClickTimer = setTimeout(() => {
      state.bestScores = { classic: 0, survival: 0, time_attack: 0, beer_party: 0, beer_defense: 0, coop_online: 0 };
      saveBestScores();
      updateHud();
      state.clearBestClickTimer = null;
    }, 260);
  });

  coopConnectButton.addEventListener("click", connectCoop);
  coopDisconnectButton.addEventListener("click", disconnectCoop);

  presetRailwayButton.addEventListener("click", () => {
    coopUrlInput.value = "wss://romanio-production.up.railway.app";
  });
  presetLanButton.addEventListener("click", () => {
    coopUrlInput.value = "ws://192.168.2.3:8765";
  });
  presetLocalButton.addEventListener("click", () => {
    coopUrlInput.value = "ws://localhost:8765";
  });

  expApplyButton.addEventListener("click", () => {
    state.experimental.pelletMagnet = expMagnet.checked;
    experimentalMenu.style.display = "none";
    updateHud();
  });

  expCloseButton.addEventListener("click", () => {
    experimentalMenu.style.display = "none";
  });

  resizeCanvas();
  detectMobileControls();
  setCoopStatus("не подключено");
  selectMode("classic");
  state.player = createPlayer();
  state.lastTime = performance.now();
  updateHud();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
